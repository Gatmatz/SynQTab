import pandas as pd
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error

from synqtab.reproducibility.ReproducibleOperations import ReproducibleOperations
from synqtab.evaluators.Evaluator import Evaluator


class MLAugmentationRegression(Evaluator):
    """ ML Augmentation Regression R2 Efficacy Evaluator. Custom implementation. Parameters:
        - [*required*] `'real_training_data'`: the real data used to train the generator
        - [*required*] `'synthetic_data'`: the synthetic data generated by the generator
        - [*required*] `'prediction_column_name'`: the name of the target column
        - [*required*] `'real_validation_data'`: the data to use for validation (unseen by the generator)
        - [*optional*] `'notes'`: True/False on whether  to include notes in the result or not.
        If absent, defaults to False.
    """
        
    def compute_result(self):
        real_training_data = self.params.get('real_training_data')
        synthetic_data = self.params.get('synthetic_data')
        prediction_column_name = self.params.get('prediction_column_name')
        real_validation_data = self.params.get('real_validation_data')
        
        # Custom implementation for regression data augmentation
        # Train on real data only (baseline)
        X_real = real_training_data.drop(columns=[prediction_column_name])
        y_real = real_training_data[prediction_column_name]

        # Train on augmented data (real + synthetic)
        augmented_data = pd.concat([real_training_data, synthetic_data], ignore_index=True)
        X_augmented = augmented_data.drop(columns=[prediction_column_name])
        y_augmented = augmented_data[prediction_column_name]

        # Validation data
        X_val = real_validation_data.drop(columns=[prediction_column_name])
        y_val = real_validation_data[prediction_column_name]

        # Train baseline model (real data only)
        baseline_model = ReproducibleOperations.get_random_forest_regressor()
        baseline_model.fit(X_real, y_real)
        baseline_pred = baseline_model.predict(X_val)
        baseline_r2 = r2_score(y_val, baseline_pred)
        baseline_mse = mean_squared_error(y_val, baseline_pred)
        baseline_mae = mean_absolute_error(y_val, baseline_pred)

        # Train augmented model (real + synthetic data)
        augmented_model = ReproducibleOperations.get_random_forest_regressor()
        augmented_model.fit(X_augmented, y_augmented)
        augmented_pred = augmented_model.predict(X_val)
        augmented_r2 = r2_score(y_val, augmented_pred)
        augmented_mse = mean_squared_error(y_val, augmented_pred)
        augmented_mae = mean_absolute_error(y_val, augmented_pred)

        # Compute improvement score (normalized between 0 and 1)
        # Higher R2 is better, so positive improvement is good
        r2_improvement = augmented_r2 - baseline_r2
        # Lower MSE is better, so we want negative change
        mse_improvement = baseline_mse - augmented_mse
        # Lower MAE is better
        mae_improvement = baseline_mae - augmented_mae
        
        if self.params.get('notes', False):
            return r2_improvement, {
                "augmented_data": {
                    "r2": augmented_r2,
                    "mse": augmented_mse,
                    "mae": augmented_mae
                },
                "real_data_baseline": {
                    "r2": baseline_r2,
                    "mse": baseline_mse,
                    "mae": baseline_mae
                },
                "parameters": {
                    "r2_improvement": r2_improvement,
                    "mse_improvement": mse_improvement,
                    "mae_improvement": mae_improvement
                }
            }
        return r2_improvement
