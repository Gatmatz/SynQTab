from enum import Enum
import pandas as pd

from synqtab.datasets import Dataset
from synqtab.evaluators.Evaluator import Evaluator


class ClassificationType(Enum):
    BINARY = 'binary'
    MULTICLASS = 'MULTICLASS'


class MLEfficacy(Evaluator):
    """ ML Efficacy Evaluator. Leverages
        https://docs.sdv.dev/sdmetrics/data-metrics/metrics-in-beta/ml-efficacy-single-table/binary-classification. Parameters:
        - [*required*] `'real_training_data'`: the real data used to train the generator
        - [*required*] `'synthetic_data'`: the synthetic data generated by the generator
        - [*required*] `'prediction_column_name'`: the name of the target column
        - [*required*] `'real_validation_data'`: the data to use for validation (unseen by the generator)
        - [*required*] `'problem_type'`: please use `'classification'` or `'regression'`
        - [*required*] `'metadata'`: sdmetrics metadata; See 
        https://docs.sdv.dev/sdmetrics/getting-started/metadata/single-table-metadata
        
        **This evaluator does not support additional details as _notes_.**
    """
        
    def _find_classification_type(self, data: pd.DataFrame, target_column: str) -> str:
        unique_values = data[target_column].nunique()
        if unique_values == 2:
            return ClassificationType.BINARY
        else:
            return ClassificationType.MULTICLASS
        
    def _get_sdmetrics_model_for_regression(self):
        from sdmetrics.single_table import LinearRegression
        return LinearRegression
    
    def _get_sdmetrics_model_for_classification(self, synthetic_data, prediction_column_name):
        classification_type = self._find_classification_type(synthetic_data, prediction_column_name)
        match classification_type:
            case ClassificationType.BINARY:
                from sdmetrics.single_table import BinaryAdaBoostClassifier
                return BinaryAdaBoostClassifier
            case ClassificationType.MULTICLASS:
                from sdmetrics.single_table import MulticlassDecisionTreeClassifier
                return MulticlassDecisionTreeClassifier
            case _ as not_implemented_category:
                raise NotImplementedError(
                    f"Unknown classification problem type. Got {not_implemented_category}. \
                        Valid options: {[option.value for option in ClassificationType]}."
                )
        
    def compute_result(self):        
        real_training_data = self.params.get('real_training_data')
        synthetic_data = self.params.get('synthetic_data')
        prediction_column_name = self.params.get('prediction_column_name')
        problem_type = self.params.get('problem_type')
        metadata = self.params.get('metadata')
        
        match problem_type.lower():
            case "regression":
                sdmetrics_evaluator = self._get_sdmetrics_model_for_regression()
            case "classification":
                sdmetrics_evaluator = self._get_sdmetrics_model_for_classification(synthetic_data, prediction_column_name)
            case _ as not_implemented_category:
                raise NotImplementedError(
                    f"Unknown problem type. Got {not_implemented_category}. \
                        Valid options: \"classification\" and \"regression\" (case insensitive)."
                )
                
        return sdmetrics_evaluator.compute(
            test_data=real_training_data,
            train_data=synthetic_data,
            target=prediction_column_name,
            metadata=metadata,
        )[0] # TODO verify and double check whether this is a tuple of one element of just a scalar

if __name__ == "__main__":
    # Example usage
    prior_config = Dataset(dataset_name="blood-transfusion-service-center",
                    mode="minio")

    prior = prior_config.fetch_prior_dataset()
    sd_metadata = prior_config.create_sdmetrics_metadata()
    prior_info = prior_config.get_config()

    evaluator = MLEfficacy(prior_info['problem_type'], prior_info['target_feature'], notes=True)
    results = evaluator.evaluate(prior, prior, metadata=sd_metadata)
    print(results)